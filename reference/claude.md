# Rust libraries for WASM-compatible FEM eigenanalysis

**Building a musical idiophone natural frequency analyzer requires assembling a custom solution from pure-Rust components.** No existing FEM framework provides complete WASM-compatible eigenvalue analysis out of the box. However, the combination of **faer** (linear algebra), **sprs** or **nalgebra-sparse** (sparse matrices), and a manually-implemented or adapted eigensolver creates a viable path. The critical gap is sparse generalized eigenvalue solving—which requires a Cholesky transformation workaround to convert Kφ = ω²Mφ into a standard problem solvable by available pure-Rust libraries.

## The pure Rust landscape strongly favors faer and nalgebra

For dense linear algebra operations, **faer** emerges as the strongest candidate for WASM-targeted FEM work. This pure-Rust library provides all essential decompositions (LU, Cholesky, QR, SVD, eigendecomposition) with performance benchmarks showing **7-17x speedups** over nalgebra for 1024×1024 matrices: Cholesky in ~8ms versus nalgebra's ~46ms, LU in ~19ms versus ~128ms. The library supports `#![no_std]` via feature flags, compiles cleanly to `wasm32-unknown-unknown`, and offers excellent memory control through its `PodStack` mechanism for deterministic allocation—crucial for WASM's constrained environment.

**nalgebra** remains an excellent alternative with explicitly documented WASM support. Its pure-Rust decompositions work directly when compiled for WebAssembly, and the ecosystem maturity (50+ million downloads, Dimforge maintenance) provides stability. For smaller matrices typical in reduced-order models, nalgebra's optimizations for 2D-4D operations may prove advantageous. The critical caveat: **avoid nalgebra-lapack**, which wraps C/Fortran BLAS/LAPACK and cannot compile to WASM.

**ndarray** should be avoided despite its NumPy-like ergonomics. While base ndarray compiles to WASM, ndarray-linalg—which provides essential decompositions—requires LAPACK bindings that fail with libc errors on WebAssembly targets.

## Sparse matrix storage works well, but sparse eigensolvers don't exist

For storing the large, sparse stiffness and mass matrices generated by FEM assembly, both **sprs** and **nalgebra-sparse** provide WASM-compatible solutions:

| Feature | sprs | nalgebra-sparse | faer sparse |
|---------|------|-----------------|-------------|
| **WASM compatible** | ✅ Excellent | ✅ Excellent | ✅ Good |
| **CSR/CSC formats** | ✅ Both | ✅ Both | ✅ Both |
| **Assembly via COO/Triplet** | ✅ TriMat | ✅ CooMatrix | ✅ |
| **Sparse Cholesky** | ✅ (LGPL) | ❌ | ✅ |
| **Sparse LU** | ❌ | ❌ | ✅ |
| **Sparse eigensolver** | ❌ | ❌ | ❌ |

For FEM assembly, sprs's `TriMat` (triplet format) handles duplicate entries naturally during element-by-element stiffness matrix construction, then converts efficiently to CSR/CSC for solving. faer's sparse module offers the most complete solver suite with Cholesky, LU, and QR factorizations for sparse systems—essential for the shift-invert transformation discussed below.

The **critical ecosystem gap**: no pure-Rust library provides an ARPACK-equivalent sparse eigensolver. Libraries like **russell** wrap LAPACK/MUMPS/SuiteSparse and cannot compile to WASM. The **arpack-ng** crate requires Fortran bindings. This forces a workaround strategy for modal analysis.

## Solving the generalized eigenvalue problem requires transformation

Computing natural frequencies requires solving Kφ = ω²Mφ where K is the stiffness matrix and M is the mass matrix. Since no pure-Rust library directly supports sparse generalized eigenvalue problems, the **Cholesky transformation method** is the recommended approach:

1. **Factor the mass matrix**: M = LLᵀ (using faer's sparse Cholesky)
2. **Transform**: C = L⁻¹ K L⁻ᵀ (now a symmetric standard eigenproblem)
3. **Solve**: Cy = λy where λ = ω² (using dense faer eigensolver)
4. **Recover**: φ = L⁻ᵀy

For larger problems where dense eigensolvers become impractical, implement **shift-invert Lanczos** iteration:

```rust
// Conceptual structure for shift-invert eigensolver
struct ShiftInvertOperator<'a> {
    lu: faer::sparse::linalg::solvers::Lu<f64>,  // factored (K - σM)
    m: &'a SparseMatrix,                          // mass matrix
}

impl MatVec for ShiftInvertOperator<'_> {
    fn apply(&self, x: &[f64], y: &mut [f64]) {
        // y = (K - σM)⁻¹ M x
        let temp = self.m.mul_vec(x);
        self.lu.solve(&temp, y);
    }
}
// Use Lanczos iteration with this operator to find eigenvalues near σ
```

The **eigenvalues** crate (pure Rust, depends on nalgebra) provides Davidson and Lanczos algorithms that compute only a few eigenvalues—ideal for modal analysis where only the lowest **5-20 modes** matter. However, it supports only standard eigenproblems, requiring the transformation above.

## Existing FEM frameworks cannot meet all requirements

**fenris** is the most promising existing framework, offering 3D tetrahedral and hexahedral elements with proper shape functions and assembly routines. Built on nalgebra, it's potentially WASM-compatible but untested. The project is marked "not recommended for general usage" with limited documentation and no eigensolvers—it handles assembly only.

**russell** provides comprehensive scientific computing capabilities including sparse solvers and tensor calculus for continuum mechanics, but **requires OpenBLAS, Intel MKL, MUMPS, and SuiteSparse**—C/Fortran libraries that cannot compile to WebAssembly.

Other crates like **tucanos** (mesh adaptation), **tritet** (mesh generation), and **gemlab** (geometry/integration) all depend on C/C++ libraries and fail the WASM requirement.

## The recommended architecture builds from components

Given the ecosystem gaps, build a custom lightweight module:

```
┌────────────────────────────────────────────────────────────┐
│  JavaScript/TypeScript Interface (wasm-bindgen)           │
├────────────────────────────────────────────────────────────┤
│  Modal Analysis Engine                                     │
│  ├─ Cholesky transformation of generalized problem        │
│  ├─ faer dense eigensolver (small systems)                │
│  └─ Lanczos iteration (larger systems)                    │
├────────────────────────────────────────────────────────────┤
│  FEM Assembly (custom, inspired by fenris)                │
│  ├─ Element library: Tet4/Tet10, Hex8/Hex20              │
│  ├─ Shape functions, Jacobians, B-matrices               │
│  └─ Sparse K, M assembly via sprs TriMat                 │
├────────────────────────────────────────────────────────────┤
│  Linear Algebra Foundation                                 │
│  ├─ faer: dense operations, eigensolvers                  │
│  ├─ faer-sparse: Cholesky, LU for shift-invert           │
│  └─ sprs/nalgebra-sparse: CSR/CSC storage                │
└────────────────────────────────────────────────────────────┘
```

## Specific library configuration for WASM targets

**faer** (primary linear algebra):
```toml
[dependencies]
faer = { version = "0.23", default-features = false, features = ["alloc"] }
```

**nalgebra** (alternative/complementary):
```toml
[dependencies]
nalgebra = { version = "0.34", features = ["libm"] }
nalgebra-sparse = "0.10"
```

**sprs** (sparse assembly):
```toml
[dependencies]
sprs = "0.11"
```

**Compilation**:
```bash
rustup target add wasm32-unknown-unknown
cargo build --target wasm32-unknown-unknown --release
wasm-opt -O3 -o optimized.wasm target/wasm32-unknown-unknown/release/fem.wasm
```

## Memory efficiency requires careful design

WASM's memory constraints demand attention to allocation patterns. faer's `PodStack` allows pre-allocating workspace memory, avoiding runtime allocations in hot loops. For sparse matrices, the standard CSR format stores `3n_nonzero + n_rows` values—efficient for FEM stiffness matrices which are typically **99%+ sparse**.

Key strategies for memory efficiency:
- Pre-allocate element stiffness matrices and reuse buffers during assembly
- Use sparse formats throughout; convert to dense only for the reduced eigenvalue problem
- Consider model reduction techniques (Guyan reduction, Craig-Bampton) to shrink the eigenvalue problem size
- For 3D bar geometries with undercuts, tetrahedral meshes with ~10,000 elements produce systems small enough for dense eigensolvers after transformation

## Practical development path forward

The estimated development effort for a minimal viable idiophone analyzer:

| Component | Effort | Notes |
|-----------|--------|-------|
| Element library (Tet4, Hex8) | ~800 LOC | Well-documented FEM theory |
| Assembly routines | ~400 LOC | Leverage sprs TriMat |
| Cholesky transformation | ~200 LOC | Use faer sparse solvers |
| Lanczos eigensolver | ~500 LOC | Adapt eigenvalues crate patterns |
| WASM interface | ~300 LOC | wasm-bindgen boilerplate |
| **Total** | ~2200 LOC | 2-4 weeks experienced Rust dev |

A December 2025 blog post at abstractnonsense.xyz demonstrates a complete eigenvalue solver implementation in Rust compiled to WASM (~84KB binary), confirming the approach is practical. The Rust scientific computing community (annual workshop, active Zulip) provides support resources as this ecosystem matures.

## Conclusion

For WASM-compatible FEM modal analysis of musical idiophones, **faer** provides the strongest foundation with its pure-Rust eigensolvers and sparse factorizations. Pair it with **sprs** or **nalgebra-sparse** for matrix assembly. The generalized eigenvalue problem requires a Cholesky transformation workaround since no direct sparse solver exists in pure Rust. Building a custom ~2000 LOC module—rather than adapting an existing framework—offers the most reliable path to a lightweight, fully WASM-compatible solution. Consider fenris as a reference implementation for element formulations, but plan to reimplement rather than directly adapt its code.
